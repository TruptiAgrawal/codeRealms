# CodeRealms Module Implementation Plan

## 1. Database Schema Design
### 1.1 New Tables Structure
```sql
-- Modules Table
CREATE TABLE modules (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    icon VARCHAR(50),
    order_index INT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Levels Table
CREATE TABLE levels (
    id INT PRIMARY KEY AUTO_INCREMENT,
    module_id INT,
    level_number INT,
    title VARCHAR(100),
    description TEXT,
    xp_reward INT DEFAULT 20,
    unlock_requirement INT DEFAULT 0, -- XP needed to unlock
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (module_id) REFERENCES modules(id)
);

-- User Progress Table
CREATE TABLE user_module_progress (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT,
    module_id INT,
    level_id INT,
    status ENUM('locked', 'available', 'in_progress', 'completed'),
    completion_percentage DECIMAL(5,2) DEFAULT 0.00,
    started_at TIMESTAMP NULL,
    completed_at TIMESTAMP NULL,
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (module_id) REFERENCES modules(id),
    FOREIGN KEY (level_id) REFERENCES levels(id)
);

-- Visualization Content Table
CREATE TABLE visualizations (
    id INT PRIMARY KEY AUTO_INCREMENT,
    level_id INT,
    type ENUM('animation', 'interactive', 'diagram', 'code_demo'),
    content_data JSON, -- Store visualization parameters
    title VARCHAR(100),
    description TEXT,
    order_index INT,
    FOREIGN KEY (level_id) REFERENCES levels(id)
);
```

### 1.2 Initial Data Population
```sql
-- Insert Modules
INSERT INTO modules (name, description, icon, order_index) VALUES
('Arrays', 'Master array data structures and operations', 'grid-3x3', 1),
('Strings', 'Learn string manipulation and algorithms', 'type', 2);

-- Insert Levels for Arrays Module
INSERT INTO levels (module_id, level_number, title, description, xp_reward) VALUES
(1, 1, 'Array Basics', 'Introduction to arrays and indexing', 25),
(1, 2, 'Array Operations', 'Learn push, pop, and common operations', 30),
(1, 3, 'Array Algorithms', 'Sorting and searching algorithms', 40);

-- Insert Levels for Strings Module
INSERT INTO levels (module_id, level_number, title, description, xp_reward) VALUES
(2, 1, 'String Fundamentals', 'Character arrays and basic operations', 25),
(2, 2, 'String Manipulation', 'Substring, concatenation, and methods', 30),
(2, 3, 'Pattern Matching', 'Regular expressions and string algorithms', 40);
```

## 2. Frontend Architecture Changes

### 2.1 Component Structure
```
src/
├── components/
│   ├── quest/
│   │   ├── QuestDashboard.jsx (existing)
│   │   ├── ModuleSelection.jsx (new)
│   │   ├── LevelSelection.jsx (new)
│   │   └── LevelContent.jsx (new)
│   ├── visualizations/
│   │   ├── ArrayVisualization.jsx (new)
│   │   ├── StringVisualization.jsx (new)
│   │   └── VisualizationEngine.jsx (new)
│   └── ui/
│       ├── ProgressBar.jsx (existing)
│       └── ModuleCard.jsx (new)
```

### 2.2 State Management (Redux/Context)
```javascript
// questSlice.js
const questSlice = createSlice({
  name: 'quest',
  initialState: {
    modules: [],
    currentModule: null,
    currentLevel: null,
    userProgress: {},
    loading: false,
    error: null
  },
  reducers: {
    setModules: (state, action) => {
      state.modules = action.payload;
    },
    selectModule: (state, action) => {
      state.currentModule = action.payload;
    },
    selectLevel: (state, action) => {
      state.currentLevel = action.payload;
    },
    updateProgress: (state, action) => {
      const { moduleId, levelId, progress } = action.payload;
      state.userProgress[`${moduleId}-${levelId}`] = progress;
    }
  }
});
```

## 3. API Endpoints Design

### 3.1 Module Endpoints
```javascript
// GET /api/modules
// Response: List of all available modules
{
  "modules": [
    {
      "id": 1,
      "name": "Arrays",
      "description": "Master array data structures",
      "icon": "grid-3x3",
      "totalLevels": 3,
      "completedLevels": 0,
      "isUnlocked": true
    }
  ]
}

// GET /api/modules/:moduleId/levels
// Response: Levels for specific module
{
  "levels": [
    {
      "id": 1,
      "levelNumber": 1,
      "title": "Array Basics",
      "description": "Introduction to arrays",
      "xpReward": 25,
      "isUnlocked": true,
      "status": "available"
    }
  ]
}

// GET /api/levels/:levelId/content
// Response: Level content including visualizations
{
  "level": {
    "id": 1,
    "title": "Array Basics",
    "content": "...",
    "visualizations": [...]
  }
}

// POST /api/user/progress
// Request: Update user progress
{
  "moduleId": 1,
  "levelId": 1,
  "status": "completed",
  "completionPercentage": 100
}
```

### 3.2 Progress Tracking
```javascript
// GET /api/user/progress
// Response: User's progress across all modules
{
  "totalXP": 0,
  "currentLevel": 1,
  "modules": [
    {
      "moduleId": 1,
      "moduleName": "Arrays",
      "completedLevels": 0,
      "totalLevels": 3,
      "progress": 0
    }
  ]
}
```

## 4. Visualization Implementation

### 4.1 Array Visualization Components
```javascript
// ArrayVisualization.jsx
const ArrayVisualization = ({ data, operation, step }) => {
  const [currentStep, setCurrentStep] = useState(0);
  
  const visualizations = {
    'create': () => <ArrayCreationViz data={data} />,
    'access': () => <ArrayAccessViz data={data} index={step} />,
    'insert': () => <ArrayInsertViz data={data} insertIndex={step} />,
    'delete': () => <ArrayDeleteViz data={data} deleteIndex={step} />
  };
  
  return (
    <div className="visualization-container">
      {visualizations[operation]()}
      <VisualizationControls 
        onStep={setCurrentStep}
        totalSteps={data.steps?.length || 1}
      />
    </div>
  );
};
```

### 4.2 String Visualization Components
```javascript
// StringVisualization.jsx
const StringVisualization = ({ text, operation, highlight }) => {
  const visualizations = {
    'charAt': () => <CharacterHighlight text={text} index={highlight} />,
    'substring': () => <SubstringViz text={text} start={highlight.start} end={highlight.end} />,
    'concat': () => <ConcatenationViz strings={text} />,
    'search': () => <PatternSearchViz text={text} pattern={highlight.pattern} />
  };
  
  return (
    <div className="string-visualization">
      {visualizations[operation]()}
    </div>
  );
};
```

## 5. User Flow Implementation

### 5.1 Module Selection Flow
```javascript
// ModuleSelection.jsx
const ModuleSelection = () => {
  const modules = useSelector(state => state.quest.modules);
  const dispatch = useDispatch();
  
  const handleModuleClick = (module) => {
    if (module.isUnlocked) {
      dispatch(selectModule(module));
      navigate(`/quest/module/${module.id}`);
    }
  };
  
  return (
    <div className="module-grid">
      {modules.map(module => (
        <ModuleCard 
          key={module.id}
          module={module}
          onClick={handleModuleClick}
        />
      ))}
    </div>
  );
};
```

### 5.2 Level Progression Logic
```javascript
// Level unlock logic
const checkLevelUnlock = (userProgress, level) => {
  if (level.levelNumber === 1) return true; // First level always unlocked
  
  const previousLevel = level.levelNumber - 1;
  const previousLevelKey = `${level.moduleId}-${previousLevel}`;
  
  return userProgress[previousLevelKey]?.status === 'completed';
};
```

## 6. XP and Progress System

### 6.1 XP Calculation
```javascript
const calculateXP = (level, performance) => {
  const baseXP = level.xpReward;
  const performanceMultiplier = {
    'perfect': 1.0,
    'good': 0.8,
    'average': 0.6,
    'needs_improvement': 0.4
  };
  
  return Math.floor(baseXP * performanceMultiplier[performance]);
};
```

### 6.2 Progress Tracking
```javascript
const updateUserProgress = async (userId, moduleId, levelId, status) => {
  const progress = {
    userId,
    moduleId,
    levelId,
    status,
    completedAt: status === 'completed' ? new Date() : null
  };
  
  await api.post('/user/progress', progress);
  
  // Update user's total XP and level
  if (status === 'completed') {
    const earnedXP = await calculateLevelXP(levelId);
    await updateUserXP(userId, earnedXP);
  }
};
```

## 7. Implementation Timeline

### Phase 1: Backend Setup
- [ ] Create database schema
- [ ] Implement API endpoints
- [ ] Set up authentication middleware
- [ ] Create seed data for modules/levels

### Phase 2: Core Frontend
- [ ] Update routing for modules/levels
- [ ] Create module selection component
- [ ] Implement level selection interface
- [ ] Build progress tracking system

### Phase 3: Visualizations
- [ ] Develop array visualization components
- [ ] Create string visualization components
- [ ] Implement interactive controls
- [ ] Add animation system

### Phase 4: Integration & Testing
- [ ] Connect frontend with backend
- [ ] Implement XP system
- [ ] Add progress persistence
- [ ] Comprehensive testing
- [ ] Performance optimization

### Phase 5: Polish & Deploy
- [ ] UI/UX refinements
- [ ] Add sound effects and animations
- [ ] Final testing and bug fixes
- [ ] Deployment and monitoring

## 8. Technical Considerations

### 8.1 Performance Optimizations
- Lazy load visualizations to reduce initial bundle size
- Cache user progress data locally
- Optimize database queries with proper indexing
- Use React.memo for visualization components

### 8.2 Scalability
- Design modular system for easy addition of new modules
- Use configuration-based approach for visualizations
- Implement role-based access for content management

### 8.3 User Experience
- Smooth transitions between modules/levels
- Clear progress indicators
- Responsive design for mobile devices
- Accessibility compliance (WCAG guidelines)

## 9. Success Metrics

- User engagement (time spent per module)
- Completion rates per level
- XP progression patterns
- User retention rates
- Performance of visualization loading times